package clojure;

import clojure.apriori.models.Part;
import clojure.java.api.Clojure;
import clojure.lang.IFn;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */

public class App {
    public void run() {

      try {
         // Load the main clojure runtime and load our custom
         // clojure script
         IFn require = Clojure.var("clojure.core", "require");
         require.invoke(Clojure.read("clojure.scripts"));
         
         // Create some new part
         Part myPart = new Part();
         myPart.setLength(100.0);
         myPart.setWidth(25.00);
         myPart.setThickness(4.0);
         myPart.setBatchSize(600);

         // Inject the part class instances into the Clojure script
         IFn assignpartFunction = Clojure.var("clojure.scripts", "assignPart");
         assignpartFunction.invoke(myPart);

         // Inject the machine name and process name that we want to cost
         IFn assignMachineFunction = Clojure.var("clojure.scripts", "assignMachine");
         assignMachineFunction.invoke("Laser Cutter");
         IFn assignProcessFunction = Clojure.var("clojure.scripts", "assignProcess");
         assignProcessFunction.invoke("Laser Cutting");

         // Get the calculation results -- batch time and batch cost
         IFn processingTimeFunction = Clojure.var("clojure.scripts", "processingTime");
         System.out.println("Processing time: " + processingTimeFunction.invoke().toString() + " mins");
         IFn batchCostFunction = Clojure.var("clojure.scripts", "batchCost");
         System.out.println("Batch Cost: $" + batchCostFunction.invoke().toString());

      } catch (Throwable e) {
         System.out.println(e.getMessage());
      }
   }

    public static void main(String[] args) {
        new App().run();
    }
}
